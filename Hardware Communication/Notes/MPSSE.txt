// Interfaces
// 	UART                     12 mbaud (default)
// 	FT245 Synchronous FIFO   40 mBps
// 	FT245 Asynchronous FIFO  8 mBps
// 	Async/Sync Bit-Bang
// 	MPSSE (JTAG SPI I2C)     30 mbps
// 	Fast Serial              12 mbps, opto-isolated
// 	CPU-Style FIFO
// 	FT1248

// Device
// 	I/O is 3.3V but 5V tolerant

// 60 FPS: 8.79 mBps (70 mbps)

// Chip Basics
// https://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT232H.pdf

// MPSSE Basics
// http://www.ftdichip.com/Support/Documents/AppNotes/AN_135_MPSSE_Basics.pdf

// MPSSE Commands
// https://www.ftdichip.com/Support/Documents/AppNotes/AN_108_Command_Processor_for_MPSSE_and_MCU_Host_Bus_Emulation_Modes.pdf

// Adaptive clocking: I don't think we need it (for ARM processors)
// Mode set: Read from (external) EEPROM on reset
// 	Is this different than regular EEPROM? There's a separate tool
// 	http://www.ftdichip.com/Resources/Utilities/FT_Prog_v1.4.zip
// 	FT_SetBitMode to change at runtime

// MPSSE
// 	CLKOUT=30MHz
// 	MPSSE mode is enabled using FT_SetBitMode with value 0x02
// 	Reset: FT_SetBitMode 0x00
// 	Master-only
// 	GPIOL1 is reserved/used in SPI
// 	MOSI/MISO have pull-ups, can be left unconnected
// 	Everything is sent over plain read/write calls to D2XX
// 	If the host and slave have different endianess might have to toggle MSB/LSB for read/write
// 	Both byte and bit based commands available
// 	Commands operate on bytes, MSB
// 	60 MHz clock. Speed = 60 / ((1 + Div) * 2) (probably)
// 	Clock div 5 enabled by default
// 	Can send on rising or falling edges. Need to check screen.
// 	Initial state of SK/TCK determines clock order
// 	Multiple commands can be sent in a single FT_Write? Not sure what the means exactly.
// 	Write buffer: 1 B command, 2 B data length, 1 - 65536 B payload
// 	Commands: op-code then 1+ parameters
// 	Bad command returns 0xFA
// 	Intentionally write bad command and check for 0xFA
// 	GPIO read: FT_Write command then FT_Read
// 	Docs looks like they reset MPSSE before closing
// 	If sent individually, as demonstrated below, the speed at which the GPIO signals can be
// 		changed is limited to the USB bus sending each FT_Write callin a separate transaction. This
// 		is one of the cases where it is desirable to chain multiple MPSSE commands into a single
// 		FT_Write call. The CS can be set, data transferred and CS cleared with one call.

// For example code below
// 	Set initial states of the MPSSE interface
// 		low byte, both pin directions and output values
// 		Pin name    Signal    Direction    Config    Initial State    Config
// 		ADBUS0      TCK/SK    output       1         high             1
// 		ADBUS1      TDI/DO    output       1         low              0
// 		ADBUS2      TDO/DI    input        0                          0
// 		ADBUS3      TMS/CS    output       1         high             1
// 		ADBUS4      GPIOL0    output       1         low              0
// 		ADBUS5      GPIOL1    output       1         low              0
// 		ADBUS6      GPIOL2    output       1         high             1
// 		ADBUS7      GPIOL3    output       1         high             1
// 	Note that since the data in subsequent sections will be clocked on the rising edge, the inital
// 		clock state of high is selected. Clocks will be generated as high-low-high. For example, in
// 		this case, data changes on the rising edge to give it enough time to have it available at
// 		the device, which will accept data *into* the target device on the falling edge.
// 		ACBUS0      GPIOH0    input        0                          0
// 		ACBUS1      GPIOH1    input        0                          0
// 		ACBUS2      GPIOH2    input        0                          0
// 		ACBUS3      GPIOH3    input        0                          0
// 		ACBUS4      GPIOH4    input        0                          0
// 		ACBUS5      GPIOH5    input        0                          0
// 		ACBUS6      GPIOH6    input        0                          0
// 		ACBUS7      GPIOH7    input        0                          0

// AN_135 code
// Open Device
// 	FT_CreateDeviceInfoList
// 	FT_Open
// MPSSE
// 	FT_ResetDevice      // No explanation
// 	FT_GetQueueStatus   // Flush via read
// 	FT_Read             // Flush via read
// 	FT_SetUSBParameters // (65536, 65535)
// 	FT_SetChars         // (false, 0, false, 0)
// 	FT_SetTimeouts      // (0, 5000)
// 	FT_SetLatencyTimer  // (1) (default: 16)
// 	FT_SetFlowControl   // (FT_FLOW_RTS_CTS, 0x00, 0x00) Turn on flow control to synchronize IN requests
// 	FT_SetBitMode       // (0x0, 0x00) Reset controller
// 	FT_SetBitMode       // (0x0, 0x02) Enable MPSSE mode
// 	Sleep(50)           // Wait for all the USB stuff to complete and work
// Loopback
// 	FT_Write            // (0x84) Enable loopback
// 	FT_GetQueueStatus   // Check the receive buffer - it should be empty
// 	FT_Write            // (0xAB) Sync via bogus command
// 	FT_Read             // Check for 0xFA 0xAB (weird loop)
// 	FT_Write            // (0x85) Disable loopback
// 	FT_GetQueueStatus   // Check the receive buffer - it should be empty
// JTAG (Hi-Speed)
// 	FT_Write            // (0x8A) Use 60MHz master clock (disable divide by 5)
// 	FT_Write            // (0x97) Turn off adaptive clocking (may be needed for ARM)
// 	FT_Write            // (0x8D) Disable three-phase clocking
// JTAG (TCK Frequency)
// TCK = 60MHz /((1 + [(1 +0xValueH*256) OR 0xValueL])*2)
// 	FT_Write            // (\x86) Set clock divisor command
// 	FT_Write            // (dwClockDivisor & 0xFF) Set 0xValueL of clock divisor
// 	FT_Write            // (dwClockDivisor >>8) & 0xFF Set 0xValueH of clock divisor
// MPSSE Initial States
// 	FT_Write            // (0x80) Configure data bits low-byte of MPSSE port
// 	FT_Write            // (0xC9) Initial state config above
// 	FT_Write            // (0xFB) Direction config above
// 	FT_Write            // (0x82) Configure data bits low-byte of MPSSE port
// 	FT_Write            // (0x00) Initial state config above
// 	FT_Write            // (0x00) Direction config above
// Serial Transmission 1
// 	FT_Write            // (0x10) Output on rising clock, no input, MSB first, clock a number of bytes out
// 	FT_Write            // (0x01) Length L
// 	FT_Write            // (0x00) Length H, Length = 0x0001 + 1
// 	FT_Write            // (0xA5) Data = 0xA50F
// 	FT_Write            // (0x0F) Data = 0xA50F
// 	Sleep(2)            // Wait for data to be transmitted and status to be returnedby the device driver. see latency timer above
// 	FT_GetQueueStatus   // Check the receive buffer - it should be empty
// Serial Transmission 2
// 	FT_Write            // (0x34) Output on rising clock, input on falling clock, MSB first, clock a number of bytes out
// 	FT_Write            // (0x01) Length L
// 	FT_Write            // (0x00) Length H, Length = 0x0001 + 1
// 	FT_Write            // (0xA5) Data = 0xA50F
// 	FT_Write            // (0x0F) Data = 0xA50F
// 	Sleep(2)
// 	FT_GetQueueStatus   // The input buffer should contain the same number of bytes as those output (loopback enabled!)
// 	FT_Read
// GPIO
// 	FT_Write            // (0x81) Get data bits, returns state of pins, either input or output on low byte of MPSSE
// 	Sleep(2)
// 	FT_GetQueueStatus
// 	FT_Read
// 	FT_Write            // (0x80) Set data bits low-byte of MPSSE port
// 	FT_Write            // (byInputBuffer[0] & 0xF7) Only change TMS/CS bit to zero
// 	FT_Write            // (0xFB) Direction config is still needed for each GPIO write
// 	Sleep(2)
// Close Device
// 	FT_SetBitMode       // (0x0, 0x00) Reset controller
// 	FT_Close
