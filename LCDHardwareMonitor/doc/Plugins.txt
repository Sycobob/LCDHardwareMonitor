/* NOTE: Plugins
 * Ok, here's (part of) the deal. Managed plugins bring in a lot of complexity.
 * Ultimately, I'm leaning toward Option 3. I don't like having to call into
 * managed code, so maybe there's a way around that. However, for now I'm
 * sticking with the simplicity of Option 1. Once we're up and running I'll
 * revisit the issue.
 *
 * Option 1: Call managed plugins through GetProcAddress.
 *  - This will always call into the default AppDomain. And the Fusion Loader
 *    will fail to find other managed dependencies (that aren't in the GAC)
 *    because they aren't in the bin path. We'll need to use AssemblyResolve to
 *    handle this. Will need a CLI Helper for this.
 * *- The catch here is that assemblies are loaded on-demand. So we can't know
 *    which folder to search in based on *when* the load occurs. However, we can
 *    make a reasonable guess at which folder to search based on the name of the
 *    requesting assembly. We'll need to keep a cache of loads that have occured
 *    because Assembly A and load B which then loads C and we need to know to
 *    use A's folder.
 *  - It's very appealing to be able to simply call every plugin through a
 *    uniform C interface. It means we don't have to care whether a plugin is
 *    managed or unmanaged.
 *  - However, it also leaves the onus of doing good interop on the plugin
 *    author (e.g. using a delegate to skirt the x64 performance hit and an
 *    instance method for a bit more speed). Can maybe provide a 'template' or
 *    some such to simplify it.
 *  - Enabling or disabling plugins would require unloading and reloading the
 *    entire CLR. This doesn't look possible.
 *  - Plugin dependencies could end up loading out of some other folder in the
 *    bin path. Probably not a big issue. Plugin authors can use strong naming.
 *  - ~NOTE~ Specifying the full path won't work for indirectly loaded
 *    assemblies (e.g. dependencies).
 *  - ~NOTE~ Could use a .config file for resolving dependencies, but
 *    AssemblyResolve is simpler.
 *
 * Option 2: Load plugins into a separate AppDomain
 *  - Means we can load and unload plugins independently of one another.
 *  - We'll have to call into the managed side of each plugin. If we call into
 *    native and the plugin calls into managed it's going to use the default
 *    AppDomain.
 *  - We take a 10x performance hit for calling across AppDomains.
 *  - I think we can return a function pointer back to the native side to hide
 *    the 'have to call into managed code' issue from native side.
 *
 * Option 3: Host the CLR from native
 *  - I haven't looked into this heavily, but currently it looks like it might
 *    be the right choice.
 *  - Basically it's Option 2 without a separate C++/CLI assembly. It should
 *    streamline things a bit.
 *  - What is perfomrmance like in this case?
 */
