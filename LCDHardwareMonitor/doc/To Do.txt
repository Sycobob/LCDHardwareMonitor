Next
	Cleanup Pass
		General
			Move InputLayout into VertexShader probably
			// TODO: Ensure this is removed from the list in partial initialization conditions
			// TODO: Widgets will be referencing these sensors.
			// TODO: Get this working
			It's time to figure out what happens when memory allocations fail
			If we give Slice a stride parameter, magic will occur
			Natvis for List and Slice
			Figure out what list[n] doesn't work in the Watch window
			OHM apparently needs to be run as admin?
			Take a hard look at ListRef
		Constant Buffers / Materials
			Combine VS and PS cbuf updating
			Extend cbufs to support all shader stages
			Simplify cbuf implementation
			Implement materials
			Allocate constant buffers from a simulation owned arena
		Logging
			// TODO: Plugin name in errors
			Decide on error vs warning policy and update all logging
			Look over logging carefully
			Add formatted logging

	Design Pass
		Can plugins share shaders? (maybe not)
		Should plugins get a raw pointer to D3D instead of having an abstracted API?
		Implement 'services' (mainly logging)
		How will managed code use native services and api? (~~probably dllimport~~) (er, function ptr like everything else?)
		Would it be better to hide Context inside SimulationState so plugins
		don't have to worry about it?
		Do we need to support people using objects in plugins (e.g do we need to
		give dtors an opportunity to run?)
		Consider *requiring* Update (and potentially other functions) for plugins. Does it make sense
			to have a Widget plugin that never draws anything (drawing happens in Update)? Or a Sensor
			that never updates sensors values (I don't think we want to encourage out-of-band updaing
			from a plugin). For Initialize, what's a WidgetPlugin that doesn't add WidgetDefinitions?
			SensorPlugins don't need Initialize though. If you have a plugin to monitor fan speeds but
			have no fans, it seems fine to provide no Sensors. Ok, but it still should have the
			opportunity to look, right?

	Implement OHM plugin
		Probably need a replacement SDK since it's unmaintained
			CPUID System Monitor SDK is one option, but it's paid
			AIDA64 doesn't have an SDK but it supports WMI and shared memory
			Rivatuner?
			HWiNFO (promising!)


Back Burner
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Handle multiple plugins in the same file (probably just a detailed error)
	Use #import instead of project references?
	Add UTF-8 support
	Runtime shader compilation
	Shader hot-reloading



Sensor Plugins
	Should report the list of available sensors during initialization
	Should be able to enable and disable sensors
		Should this be 'on demand' or as a list of requests as part of the update?
	Update should refresh the value of all *enabled* sensors
		How much do we care about the data being memory coherent?



Refactoring
	Rewrite List<T>
	Try out range based for loops
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary
	Drop some of the variable name prefixes, such as d3d
	Use this as parameter name for 'methods'
	Should const be used on parameters and locals?
	Include 'out' in out parameter names?
	Decide on in-struct initializers or not. Unify things.



Plugins
	- Version the API so it can change without breaking existing plugins.
	- Enforce the constraint that you may *ONLY* access application provided
	  services during scope of the function to which the services were passed.
	  Basically, don't save a reference and access services from a separate
	  thread. This could be detected with a 'shim' of some sort (accessor
	  function?)
	- Write a tutorial for creating plugins. Warn about loader lock. Warn about
	  using version/strong name for dependencies so you don't end up with the
	  wrong one because the name matched.
	- Create a template C++/CLI project and a tutorial for writing .NET plugins.
	- Ensure debugging for both native and managed plugins is reasonable.
	- Catch managed exceptions from the native side. Can't have them crash the
	  application.



Architecture
	- Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables
	  if dynamically linking.
	- Load default/fallback resources
