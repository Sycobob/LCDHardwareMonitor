Next
	Include types:
		public API - LHMList, LHMPluginInfo
		internal stuff - LHMPluginHeader
		useful non-API stuff - LHMDefer

		Should plugins have access to LHMMath, LHMDefer?
		LHMPluginHeader and probablyt be moved to


	Is separating PluginHeader and PluginInfo useful?
	I think we want a separate 'public api' and 'internal api'
	Raise warning level
	Leverage Scoped/defer everywhere
	Memory pools

	Is it worth abstracting a little to unify sensor and widget plugin handling?
	Implement OHM plugin
		Show on the LCD!
		Might be worthwhile to shove a userData pointer on Sensor
		Pass a logging interface
		Probably need a replacement SDK since it's unmaintained
			CPUID System Monitor SDK is one option, but it's paid
			AIDA64 doesn't have an SDK but it supports WMI and shared memory
			Rivatuner?
			HWiNFO (promising!)

	Implement dynamically sized allocations for logging and DetectPluginLanguage
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Handle multiple plugins in the same file (probably just a detailed error)
	Use #import instead of project references?
	Add UTF-8 support



Sensor Plugins
	Should report the list of available sensors during initialization
	Should be able to enable and disable sensors
		Should this be 'on demand' or as a list of requests as part of the update?
	Update should refresh the value of all *enabled* sensors
		How much do we care about the data being memory coherent?



Refactoring
	Try out range based for loops
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary
	Rewrite List<T>
	Drop some of the variable name prefixes, such as d3d
	Use this as parameter name for 'methods'
	Should const be used on parameters and locals?
	Include 'out' in out parameter names



Plugins
	- Version the API so it can change without breaking existing plugins.
	- Once everything is nailed down, sepate plugins into public and private parts
	  and remove the private parts from public API headers.
	- Enforce the constraint that you may *ONLY* access application provided
	  services during scope of the function to which the services were passed.
	  Basically, don't save a reference and access services from a separate
	  thread. This could be detected with a 'shim' of some sort (accessor
	  function?)
	- Write a tutorial for creating plugins. Warn about loader lock. Warn about
	  using version/strong name for dependencies so you don't end up with the
	  wrong one because the name matched.
	- Create a template C++/CLI project and a tutorial for writing .NET plugins.
	- Ensure debugging for both native and managed plugins is reasonable.
	- Catch managed exceptions from the native side. Can't have them crash the
	  application.



Architecture
	- Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables
	  if dynamically linking.
	- Load default/fallback resources

