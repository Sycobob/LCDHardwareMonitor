GUI Cleanup
	Send sensors
	Deal with StringSlice issues
	Implement state machine restarts
	"Deserialize" in place. Point to data in buffer!
	winmain cleanup


Next steps
	Shouldn't be allowed to fail once past init. update should just handle it
	Decide on passing args by pointer or reference
	Compile time printf replacement
	Text rendering
	Settings
	Users probably need to be able to create custom UI for plugin settings
	Ensure we're handling CloseHandle failures correctly
	Implement update rate control
		1) SetTimer: Must set system timer frequency
		2) Multimedia timers: Accurate. Appears to set system timer frequency
		3) Waitable timers
		4) Timer queue timers
		5) Threadpool timers
		6) select() (winsock2)
		7) usleep/nanosleep (posix)
		* Might be stuck changing the windows timer. Only set it when necessary. Don't set it at all
		  when on battery power (give user an option to set it anyway).
		* CreateTimerQueueTimer, timeSetEvent, timeBeginPeriod appear to all use the timer
		  resolution. CreateWaitableTimer appears to enforce an accurate average (looks like it still
		  works in multiples of the timer resolution, so still not good enough).
		  https://www.codeguru.com/cpp/w-p/system/timers/article.php/c5759/Creating-a-HighPrecision-HighResolution-and-Highly-Reliable-Timer-Utilising-Minimal-CPU-Resources.htm



Design Pass
	Can plugins share shaders? (maybe not)
	Should plugins get a raw pointer to D3D instead of having an abstracted API?
	Implement 'services' (mainly logging)
	How will managed code use native services and api? (~~probably dllimport~~) (er, function ptr
		like everything else?)
	Do we need to support people using objects in plugins (e.g do we need to give dtors an
		opportunity to run?)
	Consider *requiring* Update (and potentially other functions) for plugins. Does it make sense
		to have a Widget plugin that never draws anything (drawing happens in Update)? Or a Sensor
		that never updates sensors values (I don't think we want to encourage out-of-band updaing
		from a plugin). For Initialize, what's a WidgetPlugin that doesn't add WidgetDescs?
		SensorPlugins don't need Initialize though. If you have a plugin to monitor fan speeds but
		have no fans, it seems fine to provide no Sensors. Ok, but it still should have the
		opportunity to look, right?
	Asset loading might be slow. Do we need to do it on a background thread?



OHM Plugin
	Probably need a replacement SDK since it's unmaintained
		CPUID System Monitor SDK is one option, but it's paid
		AIDA64 doesn't have an SDK but it supports WMI and shared memory
		Rivatuner?
		HWiNFO (promising!)



Back Burner
	Can one of the template parameters to Scoped be eliminated through partial specialization?
	Allow logging from plugins
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Handle multiple plugins in the same file (probably just a detailed error)
	Use #import instead of project references?
	Add UTF-8 support
	Runtime shader compilation
	Shader hot-reloading
	Put plugins in an error state when API calls fail
	There's a frame of flicker where the old image size is drawn when zooming. Is this fixable?
	There's some sort of mouse position jump on my laptop when rotating the camera
	Re-use memory when formatting
	Use an arena for logging
	Figure out what happens when memory allocations fail



Sensor Plugins
	Should report the list of available sensors during initialization
	Should be able to enable and disable sensors
		Should this be 'on demand' or as a list of requests as part of the update?
	Update should refresh the value of all *enabled* sensors
		How much do we care about the data being memory coherent?



Refactoring
	Rewrite List<T>
	Rewrite String. String is a fucking nightmare right now.
	Passing a SliceSlice to a log format WILL NOT work and is a super likely mistake!
	Try out range based for loops
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary
	Decide on in-struct initializers or not. Unify things.



Error Handling
	Don't log immediately, but push contextual string into a list
	Each function up the stack adds its own information
	Last function to handle the error does the printing
	Might have to allocate for the formatting, so check if strings are dynamic and free them
	Maybe change functions to return a Result<T> with operator b32(), context string, etc
	Goal: only a single print occurs during an error, but it may be multiple lines
	The top level handler is the one who knowis if something is a warning or an error, not the inner
		most handler. LoadFile can't know if it's loading a cache file or a critical resource.
	Implement a Result<T> that can hold a return value or error information
	I'm sure there are places where we're going to end up in a partially initialized state when
		errors occur. We need to double down on transactional changes check all existing code.



Plugins
	Version the API so it can change without breaking existing plugins.
	Enforce the constraint that you may *ONLY* access application provided
		services during scope of the function to which the services were passed.
		Basically, don't save a reference and access services from a separate
		thread. This could be detected with a 'shim' of some sort (accessor
		function?)
	Write a tutorial for creating plugins. Warn about loader lock. Warn about
		using version/strong name for dependencies so you don't end up with the
		wrong one because the name matched.
	Create a template C++/CLI project and a tutorial for writing .NET plugins.
	Ensure debugging for both native and managed plugins is reasonable.
	Catch managed exceptions from the native side. Can't have them crash the
		application.
	Decide whether plugins needing elevation should be expressed in the plugin
		API. OHM requires elevation to work, and presumably other hardware senors
		plugins might as well. If plugins can say "i require elevation" then we
		can warn the user at startup that an enabled plugin requries elevation
		but the program is not elevated. This in turn means we are less likely
		to crash from loading that assumes elevation and break, and we don't have
		to ship with elevation enabled by default.



Architecture
	Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables
		if dynamically linking.
