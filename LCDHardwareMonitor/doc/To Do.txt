Cleanup Pass
	General
		It's time to figure out what happens when memory allocations fail
		Take a hard look at ListRef
		Improve SensorRef
		OHM apparently needs to be run as admin?
		Might want to hoist GetPluginInfo calls up to simulation
		Put plugins in an error state when API calls fail
	Constant Buffers / Materials
		Combine VS and PS cbuf updating
		Extend cbufs to support all shader stages
		Simplify cbuf implementation
		Implement materials
		Allocate constant buffers from a simulation owned arena
		// TODO: Why isn't this working?
	Renderer
		Pass name to resource creation functions
	Rewrite String
		Want a constructor that takes a format and args
		Want a scope-based RAII wrapper to auto-free
		e.g. for passing a formatted string to SetDebugObjectName
		Take String or StringSlice in all API functions
		Re-use memory when formatting
	Logging
		We *do* want context for allocation failures because a plugin could be asking for stupid
			sizes, caught in a loop, etc
		Allow logging from plugins
		Use an arena



Design Pass
	Can plugins share shaders? (maybe not)
	Should plugins get a raw pointer to D3D instead of having an abstracted API?
	Implement 'services' (mainly logging)
	How will managed code use native services and api? (~~probably dllimport~~) (er, function ptr
		like everything else?)
	Would it be better to hide Context inside SimulationState so plugins
	don't have to worry about it?
	Do we need to support people using objects in plugins (e.g do we need to
	give dtors an opportunity to run?)
	Consider *requiring* Update (and potentially other functions) for plugins. Does it make sense
		to have a Widget plugin that never draws anything (drawing happens in Update)? Or a Sensor
		that never updates sensors values (I don't think we want to encourage out-of-band updaing
		from a plugin). For Initialize, what's a WidgetPlugin that doesn't add WidgetDefinitions?
		SensorPlugins don't need Initialize though. If you have a plugin to monitor fan speeds but
		have no fans, it seems fine to provide no Sensors. Ok, but it still should have the
		opportunity to look, right?



OHM Plugin
	Probably need a replacement SDK since it's unmaintained
		CPUID System Monitor SDK is one option, but it's paid
		AIDA64 doesn't have an SDK but it supports WMI and shared memory
		Rivatuner?
		HWiNFO (promising!)



Back Burner
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Handle multiple plugins in the same file (probably just a detailed error)
	Use #import instead of project references?
	Add UTF-8 support
	Runtime shader compilation
	Shader hot-reloading



Sensor Plugins
	Should report the list of available sensors during initialization
	Should be able to enable and disable sensors
		Should this be 'on demand' or as a list of requests as part of the update?
	Update should refresh the value of all *enabled* sensors
		How much do we care about the data being memory coherent?



Refactoring
	Rewrite List<T>
	Try out range based for loops
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary
	Drop some of the variable name prefixes, such as d3d
	Use this as parameter name for 'methods'
	Should const be used on parameters and locals?
	Include 'out' in out parameter names?
	Decide on in-struct initializers or not. Unify things.
	Make private functions static



Error Handling
	Don't log immediately, but push contextual string into a list
	Each function up the stack adds its own information
	Last function to handle the error does the printing
	Might have to allocate for the formatting, so check if strings are dynamic and free them
	Maybe change functions to return a Result<T> with operator bool(), context string, etc
	Goal: only a single print occurs during an error, but it may be multiple lines
	The top level handler is the one who knowis if something is a warning or an error, not the inner
		most handler. LoadFile can't know if it's loading a cache file or a critical resource.



Plugins
	- Version the API so it can change without breaking existing plugins.
	- Enforce the constraint that you may *ONLY* access application provided
	  services during scope of the function to which the services were passed.
	  Basically, don't save a reference and access services from a separate
	  thread. This could be detected with a 'shim' of some sort (accessor
	  function?)
	- Write a tutorial for creating plugins. Warn about loader lock. Warn about
	  using version/strong name for dependencies so you don't end up with the
	  wrong one because the name matched.
	- Create a template C++/CLI project and a tutorial for writing .NET plugins.
	- Ensure debugging for both native and managed plugins is reasonable.
	- Catch managed exceptions from the native side. Can't have them crash the
	  application.



Architecture
	- Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables
	  if dynamically linking.
	- Load default/fallback resources
