Next
	Is it worth abstracting a little to unify sensor and widget plugin handling?

	Implement OHM plugin
		Show on the LCD!
		Might be worthwhile to shove a userData pointer on Sensor
		Pass a logging interface
		Probably need a replacement SDK since it's unmaintained
			CPUID System Monitor SDK is one option, but it's paid
			AIDA64 doesn't have an SDK but it supports WMI and shared memory
			Rivatuner?
			HWiNFO (promising!)

	Implement dynamically sized allocations for logging and DetectPluginLanguage
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Is separating PluginHeader and PluginInfo useful?
	Handle multiple plugins in the same file (probably just a detailed error)
	I think we want a separate 'public api' and 'internal api'
	Use #import instead of project references?
	Add UTF-8 support



Sensor Plugins
	Should report the list of available sensors during initialization
	Should be able to enable and disable sensors
		Should this be 'on demand' or as a list of requests as part of the update?
	Update should refresh the value of all *enabled* sensors
		How much do we care about the data being memory coherent?



Refactoring
	Rewrite List<T>
	Raise warning level
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary
	Maybe change .h to .hpp?
	Replace references with pointers
	Drop some of the variable name prefixes, such as d3d
	Use this as parameter name for 'methods'
	Should const be used on parameters and locals?
	Include 'out' in out parameter names
	Array and String slices?
	Pick strict C++ version



Plugins
	- Enforce the constraint that you may *ONLY* access application provided
	  services during scope of the function to which the services were passed.
	  Basically, don't save a reference and access services from a separate
	  thread. This could be detected with a 'shim' of some sort (accessor
	  function?)
	- Write a tutorial for creating plugins. Warn about loader lock. Warn about
	  using version/strong name for dependencies so you don't end up with the
	  wrong one because the name matched.
	- Create a template C++/CLI project and a tutorial for writing .NET plugins.
	- Ensure debugging for both native and managed plugins is reasonable.
	- Catch managed exceptions from the native side. Can't have them crash the
	  application.



Architecture
	- Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables
	  if dynamically linking.
	- Load default/fallback resources

