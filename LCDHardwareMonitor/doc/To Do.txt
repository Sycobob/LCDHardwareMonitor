Next
	Cleanup Pass
		Move additional include directories out of VC++ Directories in VS

		API: Probably have plugins fill a struct full of function pointers
		Can we typecheck plugin functions by making the plugin assign function
		pointers somewhere? (Can probably do this in a header since we know the
		function names). Actually, maybe this is the right way to get plugin
		functions in the first place. If we only find a single RegisterPlugin
		function, then ask the plugin to fill in a bunch of function pointers, we
		1) Get better type safety since they'll have to match the function pointer
		definition. 2) Reduce the amount of boilerplate on the application side.

		Move InputLayout into VertexShader probably
		Combine VS and PS cbuf updating
		Extend cbufs to support all shader stages
		Simplify cbuf implementation
		Implement materials
		Allocate constant buffers from a simulation owned arena
		// TODO: Plugin name in errors
		// TODO: Ensure this is removed from the list in partial initialization conditions
		// TODO: Widgets will be referencing these sensors.
		// TODO: I don't think drawing belongs in update
		// TODO: Get this working
		It's time to figure out what happens when memory allocations fail
		Decide on error vs warning policy and update all logging

	Design Pass
		Can plugins share shaders? (maybe not)
		Should plugins get a raw pointer to D3D instead of having an abstracted API?
		Implement 'services' (mainly logging)
		How will managed code use native services and api? (probably dllimport)
		Would it be better to hide Context inside SimulationState so plugins
		don't have to worry about it?
		Do we need to support people using objects in plugins (e.g do we need to
		give dtors an opportunity to run?)

	Rendering!
		Runtime shader compilation
		Shader hot-reloading

	Implement OHM plugin
		Show on the LCD!
		Might be worthwhile to shove a userData pointer on Sensor
		Probably need a replacement SDK since it's unmaintained
			CPUID System Monitor SDK is one option, but it's paid
			AIDA64 doesn't have an SDK but it supports WMI and shared memory
			Rivatuner?
			HWiNFO (promising!)

	Memory pools
		Replace array stack allocations with Lists out of a pool.
		Remove ArrayLength/Size
	Look over logging carefully
	Add formatted logging



Back Burner
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Handle multiple plugins in the same file (probably just a detailed error)
	Use #import instead of project references?
	Add UTF-8 support



Sensor Plugins
	Should report the list of available sensors during initialization
	Should be able to enable and disable sensors
		Should this be 'on demand' or as a list of requests as part of the update?
	Update should refresh the value of all *enabled* sensors
		How much do we care about the data being memory coherent?



Refactoring
	Rewrite List<T> (and rename to Array<T>)
	Try out range based for loops
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary
	Drop some of the variable name prefixes, such as d3d
	Use this as parameter name for 'methods'
	Should const be used on parameters and locals?
	Include 'out' in out parameter names?
	Decide on in-struct initializers or not. Unify things.



Plugins
	- Version the API so it can change without breaking existing plugins.
	- Once everything is nailed down, sepate plugins into public and private parts
	  and remove the private parts from public API headers.
	- Enforce the constraint that you may *ONLY* access application provided
	  services during scope of the function to which the services were passed.
	  Basically, don't save a reference and access services from a separate
	  thread. This could be detected with a 'shim' of some sort (accessor
	  function?)
	- Write a tutorial for creating plugins. Warn about loader lock. Warn about
	  using version/strong name for dependencies so you don't end up with the
	  wrong one because the name matched.
	- Create a template C++/CLI project and a tutorial for writing .NET plugins.
	- Ensure debugging for both native and managed plugins is reasonable.
	- Catch managed exceptions from the native side. Can't have them crash the
	  application.



Architecture
	- Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables
	  if dynamically linking.
	- Load default/fallback resources
