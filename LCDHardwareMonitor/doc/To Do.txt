Unify send code (queue)
Timed loop
Remove auto-connect from Send/Receive?

GUI Control
	Load/Unload plugins
	Provide input
	Add/Remove widgets
	Configure widgets
	Configure global settings (update rate)

Stuff
	Fix StringSlice trailing zero
	I think pipes want to be no-wait
	Decide on passing args by pointer or reference
	Users probably need to be able to create custom UI for plugin settings
	Ensure we're handling CloseHandle failures correctly
	Implement update rate control
		* How should this interact with the rate at which we send gui messages?
		1) SetTimer: Must set system timer frequency
		2) Multimedia timers: Accurate. Appears to set system timer frequency
		3) Waitable timers
		4) Timer queue timers
		5) Threadpool timers
		6) select() (winsock2)
		7) usleep/nanosleep (posix)
		* Might be stuck changing the windows timer. Only set it when necessary. Don't set it at all
		  when on battery power (give user an option to set it anyway).
		* CreateTimerQueueTimer, timeSetEvent, timeBeginPeriod appear to all use the timer
		  resolution. CreateWaitableTimer appears to enforce an accurate average (looks like it still
		  works in multiples of the timer resolution, so still not good enough).
		  https://www.codeguru.com/cpp/w-p/system/timers/article.php/c5759/Creating-a-HighPrecision-HighResolution-and-Highly-Reliable-Timer-Utilising-Minimal-CPU-Resources.htm



Design Pass
	Can plugins share shaders? (maybe not)
	Should plugins get a raw pointer to D3D instead of having an abstracted API?
	Implement 'services' (mainly logging)
	How will managed code use native services and api? (~~probably dllimport~~) (er, function ptr
		like everything else?)
	Do we need to support people using objects in plugins (e.g do we need to give dtors an
		opportunity to run?)
	Asset loading might be slow. Do we need to do it on a background thread?



OHM Plugin
	Probably need a replacement SDK since it's unmaintained
		CPUID System Monitor SDK is one option, but it's paid
		AIDA64 doesn't have an SDK but it supports WMI and shared memory
		Rivatuner?
		HWiNFO (promising!)



Back Burner
	Can one of the template parameters to Scoped be eliminated through partial specialization?
	Allow logging from plugins
	Is it cleaner to use the auto-COM-interface of LHMPluginLoader?
	Handle multiple plugins in the same file (probably just a detailed error)
	Use #import instead of project references?
	Add UTF-8 support
	Runtime shader compilation
	Shader hot-reloading
	Put plugins in an error state when API calls fail
	There's a frame of flicker where the old image size is drawn when zooming. Is this fixable?
	There's some sort of mouse position jump on my laptop when rotating the camera
	Re-use memory when formatting
	Use an arena for logging
	Figure out what happens when memory allocations fail
	Compile time printf replacement
	We don't support XP. Don't allow running on it.
	Decide on static or dynamic linking to e.g. the CRT. Bundle redistributables if dynamically
		linking.



Refactoring
	Rewrite List<T>
	Rewrite String. String is a fucking nightmare right now.
	Passing a SliceSlice to a log format WILL NOT work and is a super likely mistake!
	Try out range based for loops
	Ensure Platform function naming is uniform
	Decide on 'plugin loader' naming on both sides of the managed boundary



Error Handling
	Don't log immediately, but push contextual string into a list
	Each function up the stack adds its own information
	Last function to handle the error does the printing
	Might have to allocate for the formatting, so check if strings are dynamic and free them
	Maybe change functions to return a Result<T> with operator b32(), context string, etc
	Goal: only a single print occurs during an error, but it may be multiple lines
	The top level handler is the one who knows if something is a warning or an error, not the inner
		most handler. LoadFile can't know if it's loading a cache file or a critical resource.
	Implement a Result<T> that can hold a return value or error information
	I'm sure there are places where we're going to end up in a partially initialized state when
		errors occur. We need to double down on transactional changes check all existing code.



Settings
	Enable/disable sensors
	Enable/disable widgets



Plugins
	Sensors need a stable id across runs.
	Write a tutorial for creating plugins. Warn about loader lock. Warn about
		using version/strong name for dependencies so you don't end up with the
		wrong one because the name matched.
	Create a template C++/CLI project and a tutorial for writing .NET plugins.
	Ensure debugging for both native and managed plugins is reasonable.
	Catch managed exceptions from the native side. Can't have them crash the
		application.
	Decide whether plugins needing elevation should be expressed in the plugin
		API. OHM requires elevation to work, and presumably other hardware senors
		plugins might as well. If plugins can say "i require elevation" then we
		can warn the user at startup that an enabled plugin requries elevation
		but the program is not elevated. This in turn means we are less likely
		to crash from loading that assumes elevation and break, and we don't have
		to ship with elevation enabled by default.
